void Renderer::render_chunk(int start_row, int end_row, SDL_Surface* surface, const HittableList& world,
    const std::vector<std::shared_ptr<Light>>& lights, const Vec3& background_color,
    const ParallelBVHNode* bvh, const int max_samples_per_pixel, const int current_sample) {
    // Camera ve dünya tanımlamaları aynı kalabilir
 Vec3 lookfrom(-4.95, 1.3, 1.8);
 Vec3 lookat(2.8, 0.5, -1.3);
 Vec3 vup(0, 1, 0);
 int blade_count = 4;
 double vfov = 35.0;
 double aperture = 0.0;
 double focus_dist = 10.45;
 Camera cam(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, focus_dist, blade_count);  
    thread_local int local_sample_index = 0;

    const int min_samples = 2;
    const double variance_threshold = 0.2;
    const int variance_check_interval = 64;
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis_width(0, image_width - 1);
    std::uniform_int_distribution<> dis_height(0, image_height - 1);
    int chunks_count = 32;
    int chunk_index = 0;
    int total_pixels = image_width * image_height;
    int pixels_per_chunk = total_pixels / chunks_count;
    int start_pixel = chunk_index * pixels_per_chunk;
    int end_pixel = (chunk_index == chunks_count - 1) ? total_pixels : (start_pixel + pixels_per_chunk);

    for (int pixel = start_pixel; pixel < end_pixel; ++pixel) {
        int i = dis_width(gen);
        int j = dis_height(gen);

        Vec3 color_sum(0, 0, 0);
        Vec3 color_sum_sq(0, 0, 0);
        int samples = 0;

        while (samples < max_samples_per_pixel) {
            int batch_size = std::min(variance_check_interval, max_samples_per_pixel - samples);

            for (int s = 0; s < batch_size; ++s) {
                Vec2 uv = stratified_halton(i, j, samples, 1);
                Ray r = cam.get_ray(uv.u, uv.v);
                Vec3 sample_color = ray_color(r, bvh, lights, background_color, MAX_DEPTH, samples);

                color_sum += sample_color;
                color_sum_sq += sample_color * sample_color;
                samples++;
            }

            if (samples >= min_samples) {
                Vec3 mean = color_sum / samples;
                Vec3 variance = (color_sum_sq / samples) - (mean * mean);
                double max_variance = std::max({ variance.x, variance.y, variance.z });

                if (max_variance < variance_threshold) {
                    break;
                }
            }
        }

        Vec3 final_color = color_sum / samples;

        // Mevcut rengi al ve yeni renkle birleştir
        std::lock_guard<std::mutex> lock(mtx);
        Uint32* pixel_ptr = static_cast<Uint32*>(surface->pixels) + (image_height - 1 - j) * surface->pitch / 4 + i;
        Uint8 r, g, b;
        SDL_GetRGB(*pixel_ptr, surface->format, &r, &g, &b);
        Vec3 existing_color(r / 255.0, g / 255.0, b / 255.0);
        existing_color = Vec3(existing_color.x * existing_color.x, existing_color.y * existing_color.y, existing_color.z * existing_color.z); // Gamma decode

        int total_samples = current_sample + samples;
        Vec3 combined_color = (existing_color * current_sample + final_color * samples) / total_samples;

        combined_color = Vec3(sqrt(combined_color.x), sqrt(combined_color.y), sqrt(combined_color.z));

        int ir = static_cast<int>(256 * clamp(combined_color.x, 0.0, 0.999));
        int ig = static_cast<int>(256 * clamp(combined_color.y, 0.0, 0.999));
        int ib = static_cast<int>(256 * clamp(combined_color.z, 0.0, 0.999));

        *pixel_ptr = SDL_MapRGB(surface->format, ir, ig, ib);
    }
}