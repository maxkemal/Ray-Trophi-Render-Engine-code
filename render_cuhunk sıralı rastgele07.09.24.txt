void Renderer::render_chunk(int start_row, int end_row, SDL_Surface* surface, const HittableList& world,
    const std::vector<std::shared_ptr<Light>>& lights, const Vec3& background_color,
    const ParallelBVHNode* bvh, const int max_samples_per_pixel, const int current_sample) {


    thread_local int local_sample_index = 0;

    // Tüm pikselleri bir vektöre ekleyelim
    std::vector<std::pair<int, int>> pixels;
    for (int j = end_row; j >= start_row; --j) {
        for (int i = 0; i < image_width; ++i) {
            pixels.emplace_back(i, j);
        }
    }

    // Rastgele sıralama (shuffle)
    std::random_device rd;
    std::mt19937 g(rd());
    std::shuffle(pixels.begin(), pixels.end(), g);

    // Rastgele sıralı pikselleri işleme
    for (const auto& [i, j] : pixels) {
        Vec3SIMD color_sum(0, 0, 0);
        Vec3SIMD color_sum_sq(0, 0, 0);
        int samples = 0;

        while (samples < max_samples_per_pixel) {
          
            for (int s = 0; s < max_samples_per_pixel; ++s) {
                Vec2 uv = stratified_halton(i, j, samples, 1);
                Ray r = camera.get_ray(uv.u, uv.v);
                Vec3SIMD sample_color = ray_color(r, bvh, lights, background_color, MAX_DEPTH, samples);

                color_sum += sample_color;
                color_sum_sq += sample_color * sample_color;
                samples++;
            }

        }

        Vec3SIMD final_color = color_sum / samples;

        // Mevcut rengi al ve yeni renkle birleştir
        std::lock_guard<std::mutex> lock(mtx);
        Uint32* pixel_ptr = static_cast<Uint32*>(surface->pixels) + (image_height - 1 - j) * surface->pitch / 4 + i;
        Uint8 r, g, b;
        SDL_GetRGB(*pixel_ptr, surface->format, &r, &g, &b);
        Vec3SIMD existing_color(r / 255.0, g / 255.0, b / 255.0);
        existing_color = Vec3SIMD(existing_color.x() * existing_color.x(), existing_color.y() * existing_color.y(), existing_color.z() * existing_color.z()); // Gamma decode

        int total_samples = current_sample + samples;
        Vec3SIMD combined_color = (existing_color * current_sample + final_color * samples) / total_samples;

        combined_color = Vec3SIMD(sqrt(combined_color.x()), sqrt(combined_color.y()), sqrt(combined_color.z()));

        int ir = static_cast<int>(256 * clamp(combined_color.x(), 0.0f, 0.999f));
        int ig = static_cast<int>(256 * clamp(combined_color.y(), 0.0f, 0.999f));
        int ib = static_cast<int>(256 * clamp(combined_color.z(), 0.0f, 0.999f));

        *pixel_ptr = SDL_MapRGB(surface->format, ir, ig, ib);
    }
}

void Renderer::render_worker(int image_height, SDL_Surface* surface, const HittableList& world,
    const std::vector<std::shared_ptr<Light>>& lights, const Vec3& background_color,
    const ParallelBVHNode* bvh, const int samples_per_pass, const int current_sample) {

    const int chunk_size = 8; 

    while (true) {
        int start_row = next_row.fetch_add(chunk_size, std::memory_order_relaxed);
        if (start_row >= image_height) {
            break;
        }
        int end_row = std::min(start_row + chunk_size - 1, image_height - 1);
        render_chunk(start_row, end_row, surface, world, lights, background_color, bvh, samples_per_pass, current_sample);
    }
}
