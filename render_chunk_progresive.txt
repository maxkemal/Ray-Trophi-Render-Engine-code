void Renderer::render_chunk(SDL_Surface* surface, const HittableList& world,
    const std::vector<std::shared_ptr<Light>>& lights, const Vec3& background_color,
    const ParallelBVHNode* bvh, const int samples_per_pass, const int current_sample) {
    // Camera tanımlamaları aynı kalabilir
    Vec3 lookfrom(-2.2, 0.6, 1.5);
    Vec3 lookat(1.6, 0.4, -1.0);
    Vec3 vup(0, 1, 0);
    int blade_count = 4;
    double vfov = 50.0;
    double aperture = 0.0;
    double dist_to_focus = 1.5;
    Camera cam(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, dist_to_focus, blade_count);

    // Her iş parçacığı için yerel bir örnekleme indeksi ve rastgele sayı üreteci kullanın
    thread_local int local_sample_index = 0;
    thread_local std::mt19937 gen(std::random_device{}());
    std::uniform_int_distribution<> dis_width(0, image_width - 1);
    std::uniform_int_distribution<> dis_height(0, image_height - 1);

    // Belirli sayıda rastgele piksel işle
    int pixels_per_chunk = (image_width * image_height) / 16;
    for (int pixel = 0; pixel < pixels_per_chunk; ++pixel) {
        int i = dis_width(gen);
        int j = dis_height(gen);

        Vec3 new_color(0, 0, 0);
        // Accumulate colors from multiple samples
        for (int s = 0; s < samples_per_pass; ++s) {
            // Generate ray
            Vec2 uv = stratified_halton(i, j, local_sample_index, samples_per_pass);
            Ray r = cam.get_ray(uv.u, uv.v);
            // Calculate ray color
            new_color += ray_color(r, bvh, lights, background_color, MAX_DEPTH, local_sample_index);
        }

        // Mevcut rengi al ve güncelle (thread-safe olmalı)
        std::lock_guard<std::mutex> lock(mtx);
        Uint32* pixel_ptr = static_cast<Uint32*>(surface->pixels) + (image_height - 1 - j) * surface->pitch / 4 + i;
        Uint8 r, g, b;
        SDL_GetRGB(*pixel_ptr, surface->format, &r, &g, &b);
        Vec3 existing_color(r / 255.0, g / 255.0, b / 255.0);
        existing_color = Vec3(existing_color.x * existing_color.x, existing_color.y * existing_color.y, existing_color.z * existing_color.z); // Gamma decode

        // Mevcut ve yeni renkleri lineer uzayda birleştir
        int total_samples = current_sample + samples_per_pass;
        Vec3 combined_color = (existing_color * current_sample + new_color) / total_samples;

        // Gamma düzeltmesi
        combined_color = Vec3(sqrt(combined_color.x), sqrt(combined_color.y), sqrt(combined_color.z));

        // Rengi SDL piksel formatına dönüştür
        int ir = static_cast<int>(256 * clamp(combined_color.x, 0.0, 0.999));
        int ig = static_cast<int>(256 * clamp(combined_color.y, 0.0, 0.999));
        int ib = static_cast<int>(256 * clamp(combined_color.z, 0.0, 0.999));

        // SDL yüzeyinde piksel rengini ayarla
        *pixel_ptr = SDL_MapRGB(surface->format, ir, ig, ib);
    }
}

void Renderer::render_worker(int image_height, SDL_Surface* surface, const HittableList& world,
    const std::vector<std::shared_ptr<Light>>& lights, const Vec3& background_color,
    const ParallelBVHNode* bvh, const int samples_per_pass, const int current_sample) {
   
    render_chunk(surface, world, lights, background_color, bvh, samples_per_pass, current_sample);
   }