void Renderer::render_chunk(int start_row, int end_row, SDL_Surface* surface, const HittableList& world,
    const std::vector<std::shared_ptr<Light>>& lights, const Vec3& background_color,
    const ParallelBVHNode* bvh, const int initial_samples_per_pass, const int max_samples_per_pass) {
    Vec3 lookfrom(-4.95, 1.3, 1.8);
  Vec3 lookat(2.8, 0.5, -1.3);
  Vec3 vup(0, 1, 0);
  int blade_count = 4;
  double vfov = 35.0;
  double aperture = 0.0;
  double focus_dist = 10.45;
  Camera cam(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, focus_dist, blade_count);

    // Her iş parçacığı için yerel bir örnekleme indeksi kullanın
    thread_local int local_sample_index = 0;

    // Ön Yüzey Eşitleme (Düşük Örnekleme)
    std::vector<std::vector<Vec3>> preliminary_colors(image_width, std::vector<Vec3>(image_height, Vec3(0, 0, 0)));
    std::vector<std::vector<int>> sample_counts(image_width, std::vector<int>(image_height, 0));

    for (int j = end_row; j >= start_row; --j) {
        for (int i = 0; i < image_width; ++i) {
            Vec3 new_color(0, 0, 0);
            // İlk düşük örnekleme
            for (int s = 0; s < initial_samples_per_pass; ++s) {
                double u = (i + (rand() % 1000) / 1000.0) / image_width;
                double v = (j + (rand() % 1000) / 1000.0) / image_height;
                Ray r = cam.get_ray(u, v);
                new_color += ray_color(r, bvh, lights, background_color, MAX_DEPTH, local_sample_index);
            }

            // Renkleri toplama
            preliminary_colors[i][j] = new_color;
            sample_counts[i][j] = initial_samples_per_pass;
        }
    }

    // Varyans Hesaplama ve İkincil Örnekleme
    for (int j = end_row; j >= start_row; --j) {
        for (int i = 0; i < image_width; ++i) {
            Vec3 mean_color = preliminary_colors[i][j] / sample_counts[i][j];
            Vec3 variance(0, 0, 0);
            // Örneklerin varyansını hesapla
            for (int s = 0; s < sample_counts[i][j]; ++s) {
                Vec3 diff = preliminary_colors[i][j] - mean_color;
                variance += diff * diff;
            }
            variance /= sample_counts[i][j];

            // Eğer varyans yüksekse, ek örnekleme yap
            if (variance.x > 0.01 || variance.y > 0.01 || variance.z > 0.01) {
                Vec3 new_color(0, 0, 0);
                for (int s = 0; s < max_samples_per_pass; ++s) {
                    double u = (i + (rand() % 1000) / 1000.0) / image_width;
                    double v = (j + (rand() % 1000) / 1000.0) / image_height;
                    Ray r = cam.get_ray(u, v);
                    new_color += ray_color(r, bvh, lights, background_color, MAX_DEPTH, local_sample_index);
                }
                preliminary_colors[i][j] = new_color;
                sample_counts[i][j] += max_samples_per_pass;
            }
        }
    }

    // Son Renk Hesaplama ve Yazdırma
    for (int j = end_row; j >= start_row; --j) {
        for (int i = 0; i < image_width; ++i) {
            Vec3 final_color = preliminary_colors[i][j] / sample_counts[i][j];

            // Gamma düzeltmesi
            final_color = Vec3(sqrt(final_color.x), sqrt(final_color.y), sqrt(final_color.z));

            // Rengi SDL piksel formatına dönüştür
            int ir = static_cast<int>(256 * clamp(final_color.x, 0.0, 0.999));
            int ig = static_cast<int>(256 * clamp(final_color.y, 0.0, 0.999));
            int ib = static_cast<int>(256 * clamp(final_color.z, 0.0, 0.999));

            // SDL yüzeyinde piksel rengini ayarla
            std::lock_guard<std::mutex> lock(mtx);
            Uint32* pixel = static_cast<Uint32*>(surface->pixels) + (image_height - 1 - j) * surface->pitch / 4 + i;
            *pixel = SDL_MapRGB(surface->format, ir, ig, ib);
        }
    }
}
