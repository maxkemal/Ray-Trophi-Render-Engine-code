void Renderer::render_chunk(int start_row, int end_row, SDL_Surface* surface, const HittableList& world,
    const std::vector<std::shared_ptr<Light>>& lights, const Vec3& background_color,
    const ParallelBVHNode* bvh, const int max_samples_per_pixel, const int current_sample) {

    thread_local int local_sample_index = 0;

    std::mt19937 gen(rd());
    // Rastgele pikseller seçme
    int pixels_to_process = (image_width * image_height) / 75; // İşlenmesi gereken rastgele piksel sayısı
    for (int k = 0; k < pixels_to_process; ++k) {
        int i = dis_width(gen);
        int j = dis_height(gen);
        Vec3 color_sum(0, 0, 0);
        Vec3 color_sum_sq(0, 0, 0);
        int samples = 0;

        while (samples < max_samples_per_pixel) {
          
            for (int s = 0; s < max_samples_per_pixel; ++s) {
                Vec2 uv = stratified_halton(i, j, samples, 1);
                Ray r = camera.get_ray(uv.u, uv.v);
                Vec3SIMD sample_color = ray_color(r, bvh, lights, background_color, MAX_DEPTH, samples);

                color_sum += sample_color;
                color_sum_sq += sample_color * sample_color;
                samples++;
            }

        }

        Vec3SIMD final_color = color_sum / samples;      
        // Mevcut rengi al ve yeni renkle birleştir
        std::lock_guard<std::mutex> lock(mtx);
        Uint32* pixel_ptr = static_cast<Uint32*>(surface->pixels) + (image_height - 1 - j) * surface->pitch / 4 + i;
        Uint8 r, g, b;
        SDL_GetRGB(*pixel_ptr, surface->format, &r, &g, &b);
        Vec3SIMD existing_color(r / 255.0, g / 255.0, b / 255.0);
        existing_color = Vec3SIMD(existing_color.x() * existing_color.x(), existing_color.y() * existing_color.y(), existing_color.z() * existing_color.z()); // Gamma decode

        int total_samples = current_sample + samples;
        Vec3SIMD combined_color = (existing_color * current_sample + final_color * samples) / total_samples;

        combined_color = Vec3SIMD(sqrt(combined_color.x()), sqrt(combined_color.y()), sqrt(combined_color.z()));

        int ir = static_cast<int>(256 * clamp(combined_color.x(), 0.0f, 0.999f));
        int ig = static_cast<int>(256 * clamp(combined_color.y(), 0.0f, 0.999f));
        int ib = static_cast<int>(256 * clamp(combined_color.z(), 0.0f, 0.999f));

        *pixel_ptr = SDL_MapRGB(surface->format, ir, ig, ib);
    }
}
